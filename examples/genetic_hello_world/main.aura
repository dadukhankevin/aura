imports {
    import random
    import string
}

# --- Configuration Descriptions ---
desc target_string "Hello, World!"  # The goal string
desc population_size "100"          # Number of individuals per generation - Use string
desc mutation_rate "0.01"           # Probability of a character mutating - Use string
desc generations "500"             # Max number of generations to run - Use string
desc charset "Use string.printable" # Use the standard Python printable characters

# --- Genetic Algorithm Components ---
def --create_individual() -> str:
    """Creates a random string individual with the same length as @target_string using @charset."""
    --individual = Generate random string of length len(@target_string) using characters from string.printable
    Return --individual

def --calculate_fitness(--individual: str) -> float:
    """Calculates fitness as the proportion of characters matching @target_string."""
    --score = Count matching characters between --individual and @target_string
    --fitness = Calculate score / length of @target_string
    Return --fitness

def --select_parents(--population: list, --fitnesses: list) -> tuple:
    """Selects two parents using fitness proportionate selection (roulette wheel)."""
    Select two distinct parents from --population based on their corresponding --fitnesses probabilities
    Return the selected parent pair

def --crossover(--parent1: str, --parent2: str) -> str:
    """Performs single-point crossover between two parents."""
    Choose a random crossover point within the string length
    Create --child by combining first part of --parent1 and second part of --parent2
    Return --child

def --mutate(--individual: str) -> str:
    """Mutates characters in the individual based on @mutation_rate using @charset."""
    For each character in --individual:
      if random probability is less than @mutation_rate:
        Replace character with a random one from string.printable
    Return the potentially mutated --individual

# --- Main Evolution Loop ---
def --run_evolution():
    """Coordinates the genetic algorithm process for @generations."""
    # 1. Initialization
    Initialize --population list: Call @create_individual (with no arguments) @population_size times and store results.
    
    # 2. Generation Loop
    Iterate for a number of times specified by @generations, tracking current generation number:
        # 2a. Evaluation
        Calculate --fitnesses list: Apply @calculate_fitness to each individual in --population.
        Find --best_fitness and --best_individual in current --population using the --fitnesses.
        Print generation number, --best_fitness, and --best_individual.
        Check if --best_individual matches @target_string; if so, break the loop.
        
        # 2b. Selection & Reproduction
        Create empty --next_generation list.
        Repeat @population_size times to build the next generation:
             Select parent pair (--p1, --p2) from --population using @select_parents based on --fitnesses.
             Create --child via @crossover using --p1 and --p2.
             Mutate --child using @mutate (with no arguments).
             Add the result to --next_generation list.
        
        # 2c. Update Population
        Replace --population with --next_generation.

    # 3. Final Output
    After loop completes, print the final --best_individual found.

# --- Python Main Execution ---
if __name__ == "__main__":
    run_evolution() 